# 第三次作业

## H2P5

对m边形的m个点，m个边，建立对象Point(有x y字段)， Edge(有p1, p2表示两个点的字段)。

建立一颗**以y轴下界为关键字**的区间树。初始化时，扫描多边形的每个边，**求出解析式**，然后把边存入区间树中。

同时记录说有点的最大x MAX_X, 最小MIN_X，最大MAX_Y，最小MIN_Y范围。

```python

```

这一步相当于m个节点建树，复杂度O(mlgm)



对于单个节点(xi, yi)，首先判断画一条横线。在坐标系中刻画直线 y = yi, 放到树中检查与其相交的节点(递归搜索，先检查本节点的区间是否包含了，如果这个节点的y值大于搜索根节点的y值，则左右子树都要搜索，否则搜索右子树)。

对于搜索命中区间，将搜索的点带入解析式，记录求得的结果是大于0还是小于0，并记录返回。

如果返回的大于0、小于0的点总和都是奇数，则所求的点在其内。

这个操作需要命中查找O(m)次，计算曲线O(m)次，故单个点耗时O(m) (**此处仅是上界，实际耗时可能远远小于这些数，**)。

n个节点操作复杂度O(mn + mlgm)



## H3P1

采用类似 Java 中 LinkedHashmap 或者 Python 的 OrderDict 的结构，用Hashtable + 双向链表实现

需要用到的数据结构

`Node`: 有next pre key value四个字段，作为存储的单元和链表的节点

`HashTable`: 存储Key-Value的**哈希表**

`LinkedList`: 存储的**双向链表**，有head 字段 end字段

1. ​

   插入(不考虑数据过多)的时候，把数据插入，然后把这个数放到链表的最后一个元素(`LinkedList.end`)

   由于插入链表O(1), 放入数据O(1). 所以操作为O(1)的

2. 删除的时候，把双向链表的头节点(`LinkedList.head`)删除。各个操作都是O(1)

3. 访问的时候，像哈希表一样正常访问，把查找到的节点在`LinkedList`中移到LinkedList的末尾。也是O(1)

```python

```



## H3P2

看着有点像类似数字三角形的动态规划…?

设MAX_POINT_VALUE(n, i) 表示x1x2...xn到C(n, i)序列最大值，那么显然有

`MAX_VALUE = MAX(MAX_POINT_VALUE(n, i))`

`MAX_POINT_VALUE(n, I) = MAX(MAX_POINT_VALUE(n, j) * p(n - 1, j, I) * (O(n, I)))`

每一层上各点概率最大值和(且仅和)之前一层概率最大值有关。

每一点计算需要计算前一层所有点到其最大值，耗时O(m), 一层有m个可能性点, 故单层耗时O(m^2)

有n个点， 所以大概O(n * m ^ 2)

```python

```

