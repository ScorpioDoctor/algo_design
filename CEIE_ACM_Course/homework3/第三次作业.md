# 第三次作业

## H2P5

对m边形的m个点，m个边，建立对象Point(有x y字段)， Edge(有p1, p2表示两个点的字段)。

建立一颗**以y轴下界为关键字**的区间树。初始化时，扫描多边形的每个边，**求出解析式**，然后把边存入区间树中。

同时记录说有点的最大x MAX_X, 最小MIN_X，最大MAX_Y，最小MIN_Y范围。

```python
BUILD_TREE_AND_FIND_BORDER(polygon)
	// 让invert_tree 成为y轴下界为关键字，并附带有边edge信息的区间树
	// 遍历多边形中的边3
    // 让max_x, max_y为极大的值，min_x, miny为极小的值
  	for edge in polygon:
      	// 动态调整 min max
		max_x = max(edge.p1.x, edge.p2.x, max_x)
        max_y = max(edge.p1.y, edge.p2.y, max_y)
        min_x = min(edge.p1.x, edge.p2.x, min_x)
        min_y = max(edge.p1.y, edge.p2.y, min_y)
    	invert_tree.add(edges)
      
   	return invert_tree, min_x, min_y, max_x, max_y
```

这一步相当于m个节点建树，复杂度O(mlgm)



对于单个节点(xi, yi)，首先判断画一条横线。在坐标系中刻画直线 y = yi, 放到树中检查与其相交的节点(递归搜索，先检查本节点的区间是否包含了，如果这个节点的y值大于搜索根节点的y值，则左右子树都要搜索，否则搜索右子树)。

对于搜索命中区间，将搜索的点带入解析式，记录求得的结果是大于0还是小于0，并记录返回。

如果返回的大于0、小于0的点总和都是奇数，则所求的点在其内。

这个操作需要命中查找O(m)次，计算曲线O(m)次，故单个点耗时O(m) (**此处仅是上界，实际耗时可能远远小于这些数，**)。

n个节点操作复杂度O(mn + mlgm)

```python
COUNT_ALL(section_node, point):
	if section_node == Nil:
		return 0, 0
	neg = 0
	pos = 0
	if section_node.lower > point.y:
		return COUNT_ALL(section_node.left, point)
    elif section_node.higher < point.y:
    	if section_node.formula(point) > 0:
        	pos += 1
        else:
          	neg += 1
		
    neg, pos += COUNT_ALL(section_node.left, point)
    neg, pos += COUNT_ALL(section_node.right, point)
    return neg, pos
```



```python
// 遍历单个点
JUDGE(point, invert_tree)
	neg, pos = COUNT_ALL(section_tree.root, point)
    if is_odd(neg) and is_odd(pos):
      	return true
   	return false
```

## H3P1

采用类似 Java 中 LinkedHashmap 或者 Python 的 OrderDict 的结构，用Hashtable + 双向链表实现

需要用到的数据结构

`Node`: 有next pre key value四个字段，作为存储的单元和链表的节点

`HashTable`: 存储Key-Value的**哈希表**

`LinkedList`: 存储的**双向链表**，有head 字段 end字段

此外，LRU还有`size`(现有数据)，`capacity`(数据容量) 等字段

1. ​

   插入(不考虑数据过多)的时候，把数据插入，然后把这个数放到链表的最后一个元素(`LinkedList.end`)

   由于插入链表O(1), 放入数据O(1). 所以操作为O(1)的
   ```python
    PUT(lru, key, value):
        if lru.size == lru.capacity:
            // LRU满了
            POP_LRU(lru)
        cur_node = Node(key, value)
        lru.hashtable[key] = cur_node
        self.linked_list.append(cur_node)
   ```

2. 删除的时候，把双向链表的头节点(`LinkedList.head`)删除。各个操作都是O(1)

   ```python
   POP_LRU(lru):
       lru.linked_list.pop(self.linked_list.head)
   ```

3. 访问的时候，像哈希表一样正常访问，把查找到的节点在`LinkedList`中移到LinkedList的末尾。也是O(1)

   ```python
   GET(lru, key):
       node = lru.table[key]
       if node is Nil:
       	return Nil
       else:
         	// 把此节点移动到末尾
           self.linked_list.pop(node)
           self.linked_list.append(node)
           return node.value
   ```



## H3P2

看着有点像类似数字三角形的动态规划…?

设MAX_POINT_VALUE(n, i) 表示x1x2...xn到C(n, i)序列最大值，那么显然有

`MAX_VALUE = MAX(MAX_POINT_VALUE(n, i))`

`MAX_POINT_VALUE(n, I) = MAX(MAX_POINT_VALUE(n, j) * p(n - 1, j, I) * (O(n, I)))`

每一层上各点概率最大值和(且仅和)之前一层概率最大值有关。

每一点计算需要计算前一层所有点到其最大值，耗时O(m), 一层有m个可能性点, 故单层耗时O(m^2)

有n个点， 所以大概O(n * m ^ 2)

#### 代码

假设观察点类型是Point, 可以根据`p[i]` 访问第i个观测点

`Point`对象有字段`Candidate`类型的c, `p[i].c[j]`访问第i个点的第J个候选点对象,  同时`p[i].o[j]`表示这个点被选中的对应概率。

`prob(i, j, k)`表示`p[i].c[j]` -> `p[i + 1].c[k]` 的概率

```python
GET_BEST(p, prob):
    
    LEN = len(p[0].c)  # len 为可选范围的长度
    # 
    # 让 max_list 成为长度为LEN，存储概率。第一层初始化为直接概率o[i]的值
    max_list = [p[0].o[i] for i in range(LEN)]

    for i <- 1 upto LEN:
		// 让next_max成为长度为 LEN的 数组，用于存储下一层的概率
        for k <- 1 upto LEN:
        	// 计算下一层第k个的概率
            max_value = 0
            for j <- 0 upto LEN:
                max_value = max(p[i].o[k] * prob(i, j, k), max_value)
            next_max[k] = max_value
        max_list = next_max

    final_max_value = -1
    final_max_index = -1
    for i <- 0 upto LEN:
        if max_list[i] > final_max_value:
            final_max_index = i
    return final_max_index


```





